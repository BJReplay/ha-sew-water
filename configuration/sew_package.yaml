recorder:
  exclude:
    entities:
      # Disable recorder making entries for water usage
      # It causes miscalculations with the retrospective imports
      - sensor.water_usage_mains

# Define main sensors for tracking water usage - this is what historical records are imported to
template:
  - sensor:
      # Tracking water usage - mains
      - name: "Water Usage Mains"
        unique_id: water_usage_mains
        device_class: water
        state_class: total
        unit_of_measurement: "L"
        state: "{{ states('sensor.current_water_mains_usage') | float }}"
        attributes:
          sum: "{{ state_attr('sensor.current_water_mains_usage', 'sum') }}"

# These sensors serve to give the main water sensors a consistent/up to date state that can 'persist' restarts
sql:
  - name: "Current Water Mains Usage"
    unique_id: current_water_mains_usage
    unit_of_measurement: "L"
    device_class: water
    column: "sum"
    query: >
      SELECT
        max(statistics.state) as sum
      FROM
        statistics statistics
        INNER JOIN statistics_meta ON statistics.metadata_id = statistics_meta.id
      WHERE
        statistics_meta.statistic_id = 'sensor.water_usage_mains'

# This automation imports water usage up to yesterday.
automation:
  - id: aaaa2299-6e1f-4802-8e56-97f509ed0ab9
    alias: Import water usage
    description: Import water usage
    triggers:
      - trigger: time
        at: "10:30:00"
    conditions: []
    actions:
      - alias: Repeat while Next Water Date is before Yesterday and data retrieved
        repeat:
          sequence:
            - if:
                - condition: or
                  conditions:
                    - condition: state
                      entity_id: sensor.current_water_mains_usage
                      state: unavailable
                    - condition: state
                      entity_id: sensor.current_water_mains_usage
                      state: unknown
                  alias: If Water Usage Mains not set
              then:
                - action: pyscript.force_water_state
                  data:
                    stat_id: sensor.water_usage_mains
                    tally: 0
                  alias: Initialise Water Usage Mains
              alias: If Water Usage Mains not set, Initialise Water Usage Mains
            - variables:
                next_date: "{{ states('sensor.next_water_date') }}"
            - action: pyscript.import_water_usage
              metadata: {}
              data:
                mains_water_stat_id: sensor.water_usage_mains
                sew_username: !secret sew_username
                sew_password: !secret sew_password
                browserless: !secret browserless_url
                default_sew_baId: !secret sew_billing_account_id
                default_sew_meterId: !secret sew_meter_id
                target_date: "{{ next_date }}"
            - delay:
                hours: 0
                minutes: 1
                seconds: 0
                milliseconds: 0
            - variables:
                next_date: "{{ states('sensor.next_water_date') }}"
                count: "{{count + 1}}"
          while:
            - condition: template
              value_template:
                "{{ as_local(as_datetime(states('sensor.next_water_date')))
                < now() - timedelta(days = 1) }}"
              alias: If Next Water Date is before Yesterday
            - condition: template
              value_template: "{{ start_date_text != next_date }}"
              alias: Next Water Date != Start Water Date
            - condition: template
              value_template: "{{ count < 10 }}"
              alias: Count < 10
    variables:
      start_date: "{{ states('sensor.next_water_date') }}"
      next_date: empty
      last_date: empty
      count: 1
    mode: queued
    max: 2
